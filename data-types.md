**_ ============== Типы данных ============= _**

1. численные: integer, float;
2. атомы;
3. структуры: list, tuple, map;
4. идентификаторы: pid, port, reference;
5. функции;
6. binary;

**_ Числа _**
Erlang поддерживает два типа численных переменных: целочисленные и числа с плавающей точкой.

2 + 5. -> 7
49 \* 100. -> 4900
5 div 2. -> 2 --> делить целое на целое
5 rem 2. -> 1 --> взятие остатка
2#101010. -> 42 --> целое число в системе счисления основание#число

1. Числа в Erlang безразмерные - это значит что туда можно положить число любой длины

math:pow(10, 40) -> 0e40
round(math:pow(10, 40)). - 10000000000000000303786028427003666890752

**_ Числоа с плавающей запятой (float) _**

0.2 + 0.1. -> 0.30000000000000004

**_ Переменные _**
One. --> Создать переменную One
One = On = Uno = 1. --> Создать переменые One = O = Uno и прировнять их к 1
One + On. -> 2

CatAge = 23.
PeopleAge = CatAge \* 7. -> 161

Особенности:

1. Значение переменной можно присваивать только один раз.
2. Перменные должны начинаться с БОЛЬШОЙ буквы.
3. Переменные неизменяемые в Erlang, поэтому если мы хотим как то изменить переменную, то нужно создать новую User2 = User1.....

**_ Атомы _**
Атом - это константное именнованное значение. И эти значения можно сравнивать между собой.
Используются для сопоставления с образцом(pattern matching).

red. -> создать атом red
green. -> создать атом green
red == green. -> false

Особенности:

1. Имеют глобальную область видимости. Хранятся в специальной области памяти, которая называется таблица атомов. Если мы будем динамически генерировать атомы то мы можем переполнить таблицу атомов и сломать приложение
2. Не чистяться сборщиками мусора(никогда не удаляются)
3. Атомы принято писать с маленькой буквы
   atom
   atom_rule
   atom_rule@Erlang
   'atoms_rule!'
4. Можно присвоить в переменную. Var = pupil. (Создали переменную Var со значением атом(pupil))

**_ Кортеж(tuple) _**
{1, 2.4, red}. - создать кортеж

Особенности:

1. У кортежа фиксированная длинна. Это значит, что если мы создали кортеж из 3-х элементов, то добавить 4й мы не сможем.
2. Элементы кортежа безымянные. Это значит, что мы можем к ним обратиться только по их позиции.
   Tuple1 = {1, 23, 3.2, red}.
   element(3, Tuple1). -> 3.2
3. Первым элементом в кортеж обычно кладут атом(тег), который поясняет а что мы вообще храним в этом кортеже. Например:
   {point, 2, 10}. - это координата с двумя точками 2,10
   {user, "Kostya", "Bogorodskii", 22}. - это кортеж с пользователем, который хранит имя,фамилию и возраст.
   Такие атомы называют тегированными, а атом тегом.
4. Чтобы не путаться в элементах кортежи обычно делать от 2-5 элементов.
5. Кортежи могут быть вложенными. Уровень вложенности неограничен
   {area, {point, 3,10}, {point, 5, -15}}

Point = {4, 5}.
{X,Y} = Point. - Очень похоже на деструктуризацию из js. Это одна из многих форм операций сопоставления с образцом (patter matching)
X. -> 4
Y. -> 5

!!! Если нам не нужна какая-то переменная, то мы можем написать так {X,_} = Point. "_" Такая переменная всегда определена как свободная и служит универсальным элементом подстановки для сопаставления с образцом.

**_ Список(list) _**
List1 = [1,2,3,4,5].

Особенности:

1. Может хранить элементы разных типов List2 = [1,2,4.5,red, green].
2. Списки могут быть вложенными в друг друга. List4 = [1,[2,4,{point,2,3}],4.5,red, green].

!!! Для склейки списков используется операто ++ для удаления из спика -- !!!

[1,2,3,4] ++ [5,6,7]. -> [1,2,3,4,5,6,7]
[1,2,3,4] ++ [2,3]. -> [1,4]

Оба этих орпетатора ассоциативны справа. Это означат, что елементы нескольких последовательных операций ++ или -- будут обрабатыватьс справа налева.
[1,2,5] -- [1,2] -- [3].

1. Cначала у нас берется [1,2] и из него вычитается [3], что не приводит ни к каким изменениям т.к 3 нету.
2. Дальше из [1,2,5] вычитаеся [1,2], что привод к конечному результату [5].

List1 = [2,3,4].
NewList = [1|List1] -> [1,2,3,4]. Первый элемент списка [1] называется головой(головным элементом), а [2,3,4] это хвост(хвостовыми элементами)
Для их получения можно использовать hd(NewList). -> [1] или tl(NewList). -> [2,3,4]

Оператор | используется для склейки двух спсков [1 | []]. -> [1 | [2,3 |[5,6]]]. Запятая при этом между списками не нужна.

!!! Доступ к N-му элементу списка осуществляется за время O(n) !!!

=== Функции спосков ===
length(List) - вернёт длину списка.

**_ Строки _**

Проблема Erlang в работе со строками. Строки - это теже списки, пожтому записываются они соверешнно так же. Erlang напечатает список чисел в чсиловом предствалении, только если хотя бы одно из них невозможно представить в виде буквы! Настоящих строк в Erlang просто нет!
Например
[1, 2, 3, 97, 98, 5]. - всё будет так как мы и ожидаем -> [1, 2, 3, 97, 98, 5]
Однако
[97, 98] -> "ab"

**_ Булевые Boolean _**

На самом деле булевых значений нету в erlang - это просто зарезервированные атомы.

1. true and false. -> false
2. false or true. -> true
3. true xor false. -> true
4. not false. -> true
5. not (true and true). -> false

!!! Операторы and и or всегда вычисляют аргументы, находящиеся по обе стороны от оператора. Если мне нужен оператор, которые вычисляют правую сторону только при необходимости , используйте andalso и orelse. !!!

**_ Проверка на равенство _**

1. 5 =:= 5. -> true Замена == в js
2. 5 =/= 5. -> false Замена != в js
3. 5 =:= 5.0. -> false

!!! Erlang не делает различий при выполнение арифметических действий между целыми числами и числами с плавающей запятой, но он будет различать эти числа при сравнение. Именно для этого и нужны эти два оператора !!! 4. 5 == 5.0. -> true 5. 5 /= 5.0. -> false

6. > - больше чем
7. < - меньше чем
8. > = - больше или равно
9. =< - меньше или равно

!!! Erlang не позволит сложить 5 + true. -> это вызовет ошибку, однако мы всегда можем сравнить 5 =:= true. -> false !!!

0 == false. -> false
1 < false. -> true
0 > true. -> false
1 == true. -> false

**_ record _**

1. Создаём файл main.erl -> Делаем этот файл модулем -module(main).
2. Создаём сам record
   record(user, {id:: integer(), name:: string(), age:: integer(), country:: string(), city:: string()}).
3. Запуска record в консоле c помощью rr. rr("main.erl").
4. Появиться список с именем user
5. #user{}. - посмотреть все поля списка.
6. Создать нового юзера
   User1 = #user{id = 1, name = "Kostya", age = 22, country = "Russia", city = "Moscow"}.
7. Если какому-то полю мы не зададим значение, то оно останеться undefined.
8. Мы можем поменять какаю-то переменную User2 = User1#user{id = 1, name = "Igor", age = 22, country = "Russia", city = "Moscow"}.

**_ Map(карта) _**

1. Два способа создания карт в Erlang
   Map1 = #{key1 => "val1", key2 => "val2"}.
   Map2 = maps:new().
2. Значени также можно модифицировать
   Map3 = Map1#{val8 = "kostya"}.
3. Значение можно читать
   maps:find(val8, Map3).

4. Динамическая структура данных, в которую можно добавлять или же удалить значение.

5. При компиляции Map прверащается в кортеж

**_ pid / port / reference _**

1. pid является идентификатором потока, зная который, можно отправлять потоку сообщения.
   1> F = fun() -> timer:sleep(5000) end.
   #Fun<erl_eval.20.90072148>
   2> Pid = spawn(F).
   <0.36.0>
   3> Pid ! hello.
   hello

2. port является идентификатором специального процесса, связанного с сокетом.
   1> gen_tcp:listen(8080, []).
   {ok,#Port<0.588>}
   2> gen_udp:open(9090).
   {ok,#Port<0.593>}

3. reference является индентификатором общего назначения, который можно использовать по своему усмотрению. Например, как ключ для хранения объекта в ets таблице. Или им можно пометить сообщение, отправленное другому потоку, и ждать ответное сообщение, помеченное тем же ключом.
   1> Ref = make_ref().
   #Ref<0.0.0.30>
   2> Pid = spawn(timer, sleep, [10000]).
   <0.36.0>
   3> Pid ! {Ref, hello}.
   {#Ref<0.0.0.30>,hello}

**_ Бинарные _**

Представляет собой просто последовательность байт. Именно в таком виде мы получаем данные из сокета, из файла -- из внешнего мира. Эрланг очень быстро и эффективно работает с binary, и имеет удобные средства для преобразования этих байт в понятные данные.

<<1,2,3,4,5>>.

Erlang очень хорошо оптимизирован для работы с бинарным типом данных. Это является сильной стороной Erlang.
