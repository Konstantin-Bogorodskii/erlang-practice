**_ Как включить? _**

1. Заходим в нужную папку -> Взамен адрессного пути папки пишем erl
2. alt + пробел - открыть настройки коносли там можно вставить или вделить текст или поменять настройки

**_ Команды Erlang консоли _**

b(). - показать все переменные
f(). - очистить все переменные

**_ Что такое Erlang? _**
Erlang - это функциональный язык программирования. Если вам приходилось когда-либо работать с императивными языками программирования, то выражения вроде i++ для вас в порядке вещей. В функциональном программировании такие выражения не разрешаются.

**_ Чем хорош эрланг? _**

1. Виртуальная машина эрланг имеет свою реализацию многопоточности, свои планировщики, работающие поверх процессов операционной системы, и умеющие создавать и управлять десятками и сотнями тысяч потоков. Новый поток стартует за 3-5 микросекунд (не миллисекунд, а микросекунд) и занимает около 2.5 Кб памяти. У каждого потока своя область памяти и свой сборщик мусора. Нету разделяемой между потоками памяти, которой нужно управлять с помощью блокировок, и нету ошибок типа dead lock и race condition. (На самом деле не все так просто, но на начальных этапах изучения языка можно считать, что этого нет. Потоки обмениваются сообщениями друг с другом. При этом данные копируются из памяти одного потока в память другого потока. Таким образом, поток никак не может испортить чужую память. И это значительно упрощает разработку многопоточных приложений.

2. Эрланг предлагает средства (примитивы языка и архитектурные паттерны), значительно повышающие устойчивость к ошибкам.

**_ ============== Типы данных ============= _**

1. численные: integer, float;
2. атомы;
3. структуры: list, tuple, map;
4. идентификаторы: pid, port, reference;
5. функции;
6. binary;

**_ Числа _**
2 + 5. -> 7
49 \* 100. -> 4900
5 div 2. -> 2 --> делить целое на целое
5 rem 2. -> 1 --> взятие остатка
2#101010. -> 42 --> целое число в системе счисления основание#число

1. Числа в Erlang безразмерные - это значит что туда можно положить число любой длины

math:pow(10, 40) -> 0e40
round(math:pow(10, 40)). - 10000000000000000303786028427003666890752

2. Числоа с плавающей запятой

0.2 + 0.1. -> 0.30000000000000004

**_ Переменные _**
One. --> Создать переменную One
One = On = Uno = 1. --> Создать переменые One = O = Uno и прировнять их к 1
One + On. -> 2

CatAge = 23.
PeopleAge = CatAge \* 7. -> 161

Особенности:

1. Значение переменной можно присваивать только один раз.
2. Перменные должны начинаться с БОЛЬШОЙ буквы.
3. Переменные неизменяемые в Erlang, поэтому если мы хотим как то изменить переменную, то нужно создать новую User2 = User1.....

**_ Атомы _**
Атом - это константное именнованное значение. И эти значения можно сравнивать между собой.
Используются для сопоставления с образцом(pattern matching).

red. -> создать атом red
green. -> создать атом green
red == green. -> false

Особенности:

1. Имеют глобальную область видимости. Хранятся в специальной области памяти, которая называется таблица атомов.
2. Не чистяться сборщиками мусора(никогда не удаляются)
3. Если мы будем динамически генерировать атомы то мы можем переполнить таблицу атомов и сломать приложение
4. Атомы принято писать с маленькой буквы
   atom
   atom_rule
   atom_rule@Erlang
   'atoms_rule!'
5. Можно присвоить в переменную. Var = pupil. (Создали переменную Var со значением атом(pupil))

**_ Кортеж(tuple) _**
{1, 2.4, red}. - создать кортеж

Особенности:

1. У кортежа фиксированная длинна. Это значит, что если мы создали кортеж из 3-х элементов, то добавить 4й мы не сможем.
2. Элементы кортежа безымянные. Это значит, что мы можем к ним обратиться только по их позиции.
   Tuple1 = {1, 23, 3.2, red}.
   element(3, Tuple1). -> 3.2
3. Первым элементом в кортеж обычно кладут атом(тег), который поясняет а что мы вообще храним в этом кортеже. Например:
   {point, 2, 10}. - это координата с двумя точками 2,10
   {user, "Kostya", "Bogorodskii", 22}. - это кортеж с пользователем, который хранит имя,фамилию и возраст.
   Такие атомы называют тегированными, а атом тегом.
4. Чтобы не путаться в элементах кортежи обычно делать от 2-5 элементов.
5. Кортежи могут быть вложенными. Уровень вложенности неограничен
   {area, {point, 3,10}, {point, 5, -15}}

**_ Список(list) _**
List1 = [1,2,3,4,5].

Особенности:

1. Может хранить элементы разных типов List2 = [1,2,4.5,red, green].
2. Списки могут быть вложенными в друг друга. List4 = [1,[2,4,{point,2,3}],4.5,red, green].

**_ Булевые Boolean _**

**_ record _**

1. Создаём файл main.erl -> Делаем этот файл модулем -module(main).
2. Создаём сам record
   record(user, {id:: integer(), name:: string(), age:: integer(), country:: string(), city:: string()}).
3. Запуска record в консоле c помощью rr. rr("main.erl").
4. Появиться список с именем user
5. #user{}. - посмотреть все поля списка.
6. Создать нового юзера
   User1 = #user{id = 1, name = "Kostya", age = 22, country = "Russia", city = "Moscow"}.
7. Если какому-то полю мы не зададим значение, то оно останеться undefined.
8. Мы можем поменять какаю-то переменную User2 = User1#user{id = 1, name = "Igor", age = 22, country = "Russia", city = "Moscow"}.

**_ Map(карта) _**

1. Два способа создания карт в Erlang
   Map1 = #{key1 => "val1", key2 => "val2"}.
   Map2 = maps:new().
2. Значени также можно модифицировать
   Map3 = Map1#{val8 = "kostya"}.
3. Значение можно читать
   maps:find(val8, Map3).

4. Динамическая структура данных, в которую можно добавлять или же удалить значение.
