Erlang в поисковике windows

b(). - показать все переменные
f(). - очистить все переменные

**_ Что такое Erlang? _**
Erlang - это функциональный язык программирования. Если вам приходилось когда-либо работать с императивными языками программирования, то выражения вроде i++ для вас в порядке вещей. В функциональном программировании такие выражения не разрешаются.

**_ Чем хорош эрланг? _**

1. Виртуальная машина эрланг имеет свою реализацию многопоточности, свои планировщики, работающие поверх процессов операционной системы, и умеющие создавать и управлять десятками и сотнями тысяч потоков. Новый поток стартует за 3-5 микросекунд (не миллисекунд, а микросекунд) и занимает около 2.5 Кб памяти. У каждого потока своя область памяти и свой сборщик мусора. Нету разделяемой между потоками памяти, которой нужно управлять с помощью блокировок, и нету ошибок типа dead lock и race condition. (На самом деле не все так просто, но на начальных этапах изучения языка можно считать, что этого нет. Потоки обмениваются сообщениями друг с другом. При этом данные копируются из памяти одного потока в память другого потока. Таким образом, поток никак не может испортить чужую память. И это значительно упрощает разработку многопоточных приложений.

2. Эрланг предлагает средства (примитивы языка и архитектурные паттерны), значительно повышающие устойчивость к ошибкам.

**_ ============== Типы данных ============= _**

1. численные: integer, float;
2. атомы;
3. структуры: list, tuple, map;
4. идентификаторы: pid, port, reference;
5. функции;
6. binary;

**_ Числа _**
2 + 5. -> 7
49 \* 100. -> 4900
5 div 2. -> 2 --> делить целое на целое
5 rem 2. -> 1 --> взятие остатка
2#101010. -> 42 --> целое число в системе счисления основание#число

1. Числа в Erlang безразмерные - это значит что туда можно положить число любой длины

math:pow(10, 40) -> 0e40
round(math:pow(10, 40)). - 10000000000000000303786028427003666890752

2. Числоа с плавающей запятой

0.2 + 0.1. -> 0.30000000000000004

**_ Переменные _**
One. --> Создать переменную One
One = On = Uno = 1. --> Создать переменые One = O = Uno и прировнять их к 1
One + On. -> 2

CatAge = 23.
PeopleAge = CatAge \* 7. -> 161

Особенности:

1. Значение переменной можно присваивать только один раз.
2. Перменные должны начинаться с БОЛЬШОЙ буквы.

**_ Атомы _**
Атом - это константное именнованное значение. И эти значения можно сравнивать между собой.
Используются для сопоставления с образцом(pattern matching).

red. -> создать атом red
green. -> создать атом green
red == green. -> false

Особенности:

1. Имеют глобальную область видимости
2. Хранятся в специальной области памяти, которая называется таблица атомов
3. Не чистяться сборщиками мусора(никогда не удаляются)
4. Если мы будем динамически генерировать атомы то мы можем переполнить таблицу атомов и сломать приложение
5. Атомы принято писать с маленькой буквы
   atom
   atom_rule
   atom_rule@Erlang
   'atoms_rule!'

**_ Кортеж(tuple) _**
{1, 2.4, red}. - создать кортеж

Особенности:

1. У кортежа фиксированная длинна. Это значит, что если мы создали кортеж из 3-х элементов, то добавить 4й мы не сможем
2. Элементы кортежа безымянные. Это значит, что мы можем к ним обратиться по их позиции.
   Tuple1 = {1, 23, 3.2, red}.
   element(3, Tuple1). -> 3.2
3. Первым элементом в кортеж обычно кладут атом(тег), который поясняет а что мы вообще храним в этом кортеже. Например:
   {point, 2, 10}. - это координата с двумя точками 2,10
   {user, "Kostya", "Bogorodskii", 22}. - это кортеж с пользователем, который хранит имя,фамилию и возраст.
   Такие атомы называют тегированными, а атом тегом.
4. Чтобы не путаться в элементах кортежи обычно делать от 2-5 элементов.
5. Кортежи могут быть вложенными. Уровень вложенности неограничен
   {area, {point, 3,10}, {point, 5, -15}}

**_ Список(list) _**
List1 = [1,2,3,4,5].

Особенности:

1. Может хранить элементы разных типов
2. Списки могут быть вложенными в друг друга.
3.

**_ Булевые Boolean _**

**_ record _**

record(user, {id:: integer(), name:: string(), age:: integer(), country:: string(), city:: string()}).
